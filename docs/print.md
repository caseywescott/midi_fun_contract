Cairo provides two macros to print standard data types:

println! which prints on a new line
print! with inline printing
Both take a ByteArray string as first parameter (see Data Types), which can be a simple string to print a message or a string with placeholders to format the way values are printed.

There are two ways to use these placeholders and both can be mixed:

empty curly brackets {} are replaced by values given as parameters to the print! macro, in the same order.
curly brackets with variable names are directly replaced by the variable value.
Here are some examples:

#[executable]
fn main() {
let a = 10;
let b = 20;
let c = 30;

    println!("Hello world!");
    println!("{} {} {}", a, b, c); // 10 20 30
    println!("{c} {a} {}", b); // 30 10 20

}
print! and println! macros use the Display trait under the hood, and are therefore used to print the value of types that implement it. This is the case for basic data types, but not for more complex ones. If you try to print complex data type values with these macros, e.g. for debugging purposes, you will get an error. In that case, you can either manually implement the Display trait for your type or use the Debug trait (see below).

Formatting
Cairo also provides a useful macro to handle string formatting: format!. This macro works like println!, but instead of printing the output to the screen, it returns a ByteArray with the contents. In the following example, we perform string concatenation using either the + operator or the format! macro. The version of the code using format! is much easier to read, and the code generated by the format! macro uses snapshots, so that this call doesn't take ownership of any of its parameters.

#[executable]
fn main() {
let s1: ByteArray = "tic";
let s2: ByteArray = "tac";
let s3: ByteArray = "toe";
let s = s1 + "-" + s2 + "-" + s3;
// using + operator consumes the strings, so they can't be used again!

    let s1: ByteArray = "tic";
    let s2: ByteArray = "tac";
    let s3: ByteArray = "toe";
    let s = format!("{s1}-{s2}-{s3}"); // s1, s2, s3 are not consumed by format!
    // or
    let s = format!("{}-{}-{}", s1, s2, s3);

    println!("{}", s);

}
Printing Custom Data Types
As previously explained, if you try to print the value of a custom data type with print! or println! macros, you'll get an error telling you that the Display trait is not implemented for your custom type:

error: Trait has no implementation in context: core::fmt::Display::<package_name::struct_name>
The println! macro can do many kinds of formatting, and by default, the curly brackets tell println! to use formatting known as Display - output intended for direct end user consumption. The primitive types we've seen so far implement Display by default because there's only one way you'd want to show a 1 or any other primitive type to a user. But with structs, the way println! should format the output is less clear because there are more display possibilities: Do we want commas or not? Do we want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Cairo doesn't try to guess what we want, and structs don't have a provided implementation of Display to use with println! and the {} placeholder.

Here is the Display trait to implement:

trait Display<T> {
fn fmt(self: @T, ref f: Formatter) -> Result<(), Error>;
}
The second parameter f is of type Formatter, which is just a struct containing a ByteArray, representing the pending result of formatting:

#[derive(Default, Drop)]
pub struct Formatter {
/// The pending result of formatting.
pub buffer: ByteArray,
}
Knowing this, here is an example of how to implement the Display trait for a custom Point struct:

use core::fmt::{Display, Error, Formatter};

#[derive(Copy, Drop)]
struct Point {
x: u8,
y: u8,
}

impl PointDisplay of Display<Point> {
fn fmt(self: @Point, ref f: Formatter) -> Result<(), Error> {
let str: ByteArray = format!("Point ({}, {})", *self.x, *self.y);
f.buffer.append(@str);
Ok(())
}
}

#[executable]
fn main() {
let p = Point { x: 1, y: 3 };
println!("{}", p); // Point: (1, 3)
}
Cairo also provides the write! and writeln! macros to write formatted strings in a formatter. Here is a short example using write! macro to concatenate multiple strings on the same line and then print the result:

use core::fmt::Formatter;

#[executable]
fn main() {
let mut formatter: Formatter = Default::default();
let a = 10;
let b = 20;
write!(formatter, "hello");
write!(formatter, "world");
write!(formatter, " {a} {b}");

    println!("{}", formatter.buffer); // helloworld 10 20

}
It is also possible to implement the Display trait for the Point struct using these macros, as shown here:

use core::fmt::{Display, Error, Formatter};

#[derive(Copy, Drop)]
struct Point {
x: u8,
y: u8,
}

impl PointDisplay of Display<Point> {
fn fmt(self: @Point, ref f: Formatter) -> Result<(), Error> {
let x = *self.x;
let y = *self.y;

        writeln!(f, "Point ({x}, {y})")
    }

}

#[executable]
fn main() {
let p = Point { x: 1, y: 3 };
println!("{}", p); // Point: (1, 3)
}
Printing complex data types this way might not be ideal as it requires additional steps to use the print! and println! macros. If you need to print complex data types, especially when debugging, use the Debug trait described below instead.

## MIDI Cairo Code Generation

This project includes specialized functionality for generating Cairo code from MIDI data structures. The `midi_2_cairo_print.cairo` test file provides two main functions:

### 1. Standard Test Output (`midi_to_cairo_file_test`)

Generates Cairo code with test metadata included. This is useful for debugging and development.

### 2. Clean Code Generation (`midi_to_cairo_file_output_test`)

Generates clean, production-ready Cairo code without test metadata. This function produces properly formatted Cairo code that can be directly used in projects.

### Output File Generation

While Scarb doesn't natively support saving test output to files, several solutions are provided:

#### Option 1: Simple Redirection

```bash
# Save all output (including test info)
SCARB_UI_VERBOSITY=quiet scarb test -- --filter midi_to_cairo_file_test > output.cairo 2>&1

# Save clean output only (recommended)
SCARB_UI_VERBOSITY=quiet scarb test -- --filter midi_to_cairo_file_output_test 2>&1 | \
grep -v "running\|test\|gas usage\|test result" > clean_output.cairo
```

#### Option 2: Automated Script

Use the provided `scripts/generate_cairo_output.sh` script:

```bash
./scripts/generate_cairo_output.sh                    # saves to generated_midi.cairo
./scripts/generate_cairo_output.sh my_custom_file.cairo  # saves to custom filename
```

### Generated Output Format

The generated Cairo code includes:

- Proper import statements for MIDI types
- Complete MIDI struct definition
- All MIDI events (NoteOn, NoteOff, SetTempo, etc.)
- Correct Cairo syntax with proper indentation
- Ready-to-use code structure

Example output:

```cairo
use koji::math::Time;
use koji::midi::types::{Midi, Message, NoteOn, NoteOff, SetTempo, TimeSignature, ControlChange, PitchWheel, AfterTouch, PolyTouch, Modes};

fn midi() -> Midi {
    Midi {
        events: array![
            Message::SET_TEMPO(SetTempo { tempo: 251046, time: Option::Some(0) }),
            Message::NOTE_ON(NoteOn { channel: 0, note: 60, velocity: 100, time: 100 }),
            Message::NOTE_OFF(NoteOff { channel: 0, note: 60, velocity: 100, time: 2000 }),
        ].span()
    }
}
```
